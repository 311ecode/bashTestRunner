# Implementation Guide: bashTestRunner Test Suites ğŸš€

## Overview ğŸŒŸ

Welcome to the bashTestRunner framework! This guide helps you craft robust, fun-to-read test suites inspired by the ModelSelectionStrategy example. Create isolated, self-contained test filesâ€”no need to embed the full bashTestRunner code. Let's make testing exciting with emojis for vibes! ğŸ˜

## Core Concepts ğŸ› ï¸

### What This Framework Provides

- **Automated Test Execution** ğŸ¤–: Discovers and runs tests automaticallyâ€”no manual setup drama!
- **Environment Isolation** ğŸ”’: Modify vars safely; everything restores like magic. No test cross-talk! âœ¨
- **Flexible Test Organization** ğŸ“‚: Ignore tests or group them easily. Skip the boring ones! ğŸš«
- **On-Demand Execution** âš¡: Tests fire up when you run the script. Instant gratification!

## File Structure Template - Nested Test Runner Approach ğŸ“„

Here's your blueprint for a nested test suite. It gives **awesome error reporting** with paths like: `testYourFeature -> testBasicFunctionality -> assertion fail` âŒ. Super helpful for debugging!

```bash
#!/usr/bin/env bash
# Copyright and licensing info here ğŸ“œ

# @file yourTestFile.sh
# @brief Test suite description
# @description Comprehensive tests using bashTestRunner framework

# Main test suite function with nested structure ğŸ¯
testYourFeature() {
  export LC_NUMERIC=C  # ğŸ”¢ Ensures consistent numbersâ€”must-have!

  # Define individual test functions INSIDE the main runner ğŸ§©
  testBasicFunctionality() {
    echo "ğŸ§ª Testing basic functionality"
    # Your test code here...
    return 0  # âœ… Success!
  }

  testErrorHandling() {
    echo "âš ï¸ Testing error conditions"
    # Simulate oops moments...
    return 0  # âœ… Handled!
  }

  testEnvironmentVariables() {
    echo "ğŸŒ Testing env var handling"
    # Play with globals safely...
    return 0  # âœ… Restored!
  }

  testEdgeCases() {
    echo "ğŸ§¨ Testing edge cases"
    # Push limits! ğŸ’¥
    return 0  # âœ… Survived!
  }

  # Test function registry ğŸ“‹
  local test_functions=(
    "testBasicFunctionality"
    "testErrorHandling"
    "testEnvironmentVariables"
    "testEdgeCases"
  )

  local ignored_tests=()  # ğŸš« Add names to skip, e.g., "testEdgeCases"

  bashTestRunner test_functions ignored_tests
  return $?  # ğŸ‰ Done!
}

# Execute if run directly ğŸš€
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  testYourFeature
fi
```

**Why Nested?** Better encapsulation, organization, and hierarchical error vibes! ğŸ“Š

## Essential Requirements âš ï¸

### LC_NUMERIC Setting ğŸ”¢

**Must-Do**: Set `LC_NUMERIC=C` for consistent numeric formatting. Avoid locale surprises! ğŸ˜±

**Options**:
1. **Export for All** (Recommended for multi-ops):
   ```bash
   export LC_NUMERIC=C
   bashTestRunner test_functions ignored_tests
   ```
2. **One-Off**:
   ```bash
   LC_NUMERIC=C bashTestRunner test_functions ignored_tests
   ```

Both keep numbers reliable across systems. ğŸŒ

## Step 1: Define Your Test Suite Structure ğŸ—ï¸

Start with a main function listing your tests:

```bash
testYourFeature() {
  local test_functions=(
    "testFirstScenario"  # ğŸ Start here
    "testSecondScenario" # ğŸ“ˆ Build up
    "testErrorCondition" # ğŸš¨ Handle fails
  )

  local ignored_tests=()  # ğŸš« Skip if flaky

  bashTestRunner test_functions ignored_tests
  return $?  # ğŸ¯ Exit status
}
```

## Step 2: Implement Individual Test Functions (Nested Style) ğŸ”§

Define tests **inside** the main runner for epic error tracing! ğŸ“

```bash
testYourFeature() {
  # Nested tests for better vibes ğŸ§‘â€ğŸ”¬
  testFirstScenario() {
    echo "ğŸ§ª Testing basic functionality"

    # Save env state ğŸ”’
    local saved_var="${IMPORTANT_VAR:-}"

    # Setup test env ğŸŒ
    export IMPORTANT_VAR="test_value"

    # Run the thing! âš™ï¸
    local result=$(yourFunctionToTest "test input")

    # Restore like a pro âœ¨
    if [[ -n "$saved_var" ]]; then
      export IMPORTANT_VAR="$saved_var"
    else
      unset IMPORTANT_VAR
    fi

    # Assert! âœ…
    if [[ "$result" == "expected_output" ]]; then
      echo "âœ… SUCCESS: Test passed"
      return 0
    else
      echo "âŒ ERROR: Expected 'expected_output', got '$result'"
      return 1
    fi
  }

  testSecondScenario() {
    echo "ğŸ”„ Testing another scenario"
    # More fun here...
    return 0  # âœ…
  }

  # Registry at end ğŸ“‹
  local test_functions=(
    "testFirstScenario"
    "testSecondScenario"
  )

  local ignored_tests=()

  # LC_NUMERIC vibes ğŸ”¢
  bashTestRunner test_functions ignored_tests

  return $?  # ğŸ‰
}
```

**Nested Wins**: Clear paths like `testYourFeature -> testFirstScenario -> fail` for debugging joy! ğŸ•µï¸â€â™‚ï¸

## Step 3: Environment Management Best Practices ğŸ›¡ï¸

**Save First**: Always backup vars before tweaks! ğŸ“¥

```bash
local saved_strategies="${ModelSelectionStrategies:-}"
local saved_api_key="${API_KEY:-}"
```

**Restore Cleanly**: Use unset logic for pristine state! ğŸ§¹

```bash
if [[ -n "$saved_strategies" ]]; then
  export ModelSelectionStrategies="$saved_strategies"
else
  unset ModelSelectionStrategies
fi
```

**Temp Files**: Cleanup crew on duty! ğŸ—‘ï¸

```bash
local temp_output=$(mktemp)
# Use it... ğŸ“
rm -f "$temp_output"  # Gone!
```

## Step 4: Testing Different Scenarios ğŸ­

**Success Path** âœ…:

```bash
testUserPreferenceStrategy() {
  echo "ğŸ§‘â€ğŸ’¼ Testing user prefs"
  export USER_PREFERRED_MODEL="preferred:model"
  local result=$(selectModelWithStrategy "test prompt")

  if [[ "$result" == "preferred:model" ]]; then
    echo "âœ… SUCCESS: Preference honored!"
    return 0
  fi
}
```

**Error Path** âš ï¸:

```bash
testMissingDependency() {
  echo "ğŸš« Testing missing deps"
  unset REQUIRED_API_KEY

  local temp_output=$(mktemp)
  yourFunction "test" 2>"$temp_output" >/dev/null

  if grep -q "Expected error message" "$temp_output"; then
    echo "âœ… SUCCESS: Error handled!"
    rm -f "$temp_output"
    return 0
  fi
}
```

**Fallback Chain** ğŸ”„:

```bash
testStrategyFallback() {
  echo "ğŸ”„ Testing fallbacks"
  export STRATEGIES="primary,secondary,tertiary"
  unset PRIMARY_CONFIG  # Force fallback! ğŸ’¥
  export SECONDARY_CONFIG="working"

  local result=$(executeWithFallback "input")
  # Verify secondary kicked in! ğŸ¦¸
}
```

## Advanced Patterns ğŸš€

### Testing Strategy Chains ğŸ”—

```bash
testComplexFallback() {
  echo "ğŸ”— Testing chain fallbacks"
  export STRATEGY_CHAIN="strategy1,strategy2,strategy3"
  unset STRATEGY1_REQUIREMENT
  unset STRATEGY2_REQUIREMENT
  export STRATEGY3_REQUIREMENT="available"

  local result=$(executeStrategies "context")

  if [[ "$result" == "strategy3:output" ]]; then
    echo "âœ… SUCCESS: Fallback chain works!"
    return 0
  fi
}
```

### Testing Availability Checks ğŸ”

```bash
testAvailabilityLogic() {
  echo "ğŸ” Testing resource checks"

  # Unavailable? âŒ
  unset RESOURCE_KEY
  if isResourceAvailable "resource:name"; then
    echo "âŒ ERROR: Should not be available!"
    return 1
  fi

  # Available? âœ…
  export RESOURCE_KEY="test-key"
  if ! isResourceAvailable "resource:name"; then
    echo "âŒ ERROR: Should be available!"
    return 1
  fi

  echo "âœ… SUCCESS: Checks work!"
  return 0
}
```

## Framework Integration - Zero Configuration ğŸ†“

bashTestRunner is **auto-magically available**! No sourcing, no PATH tweaks, no code embeds. Just call `bashTestRunner`â€”the system handles it. Clean and effortless! ğŸŒˆ

## Test Function Requirements ğŸ“

**Contract**:
- Return 0 for âœ… PASS
- Return 1 for âŒ FAIL
- Echo clear messages! ğŸ’¬

```bash
testExample() {
  echo "ğŸ§ª Testing something specific"

  if [[ condition_met ]]; then
    echo "âœ… SUCCESS: Test description"
    return 0
  else
    echo "âŒ ERROR: Expected X, got Y"
    return 1
  fi
}
```

## Best Practices Summary â­

- **Isolation** ğŸ”’: Tests independentâ€”no side effects!
- **Descriptive Names** ğŸ“›: Explain what's tested.
- **Environment Safety** ğŸ›¡ï¸: Save/restore vars always.
- **Clear Output** ğŸ’¬: Expected vs actual + emojis! ğŸ‰
- **Error Handling** âš ï¸: Test success AND failure paths.
- **Documentation** ğŸ“–: Describe validations briefly.
- **Modular Design** ğŸ§©: Group related, keep focused.

Build powerful suites with flairâ€”happy testing! ğŸš€
